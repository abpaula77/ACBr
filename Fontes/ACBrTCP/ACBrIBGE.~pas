{******************************************************************************}
{ Projeto: Componentes ACBr                                                    }
{  Biblioteca multiplataforma de componentes Delphi para interação com equipa- }
{ mentos de Automação Comercial utilizados no Brasil                           }
{                                                                              }
{ Direitos Autorais Reservados (c) 2004 Daniel Simoes de Almeida               }
{                                                                              }
{ Colaboradores nesse arquivo:                                                 }
{                                                                              }
{  Você pode obter a última versão desse arquivo na pagina do  Projeto ACBr    }
{ Componentes localizado em      http://www.sourceforge.net/projects/acbr      }
{                                                                              }
{ Esse arquivo usa a classe  SynaSer   Copyright (c)2001-2003, Lukas Gebauer   }
{  Project : Ararat Synapse     (Found at URL: http://www.ararat.cz/synapse/)  }
{                                                                              }
{  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la }
{ sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela  }
{ Free Software Foundation; tanto a versão 2.1 da Licença, ou (a seu critério) }
{ qualquer versão posterior.                                                   }
{                                                                              }
{  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM   }
{ NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU      }
{ ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor}
{ do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)              }
{                                                                              }
{  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto}
{ com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,  }
{ no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.          }
{ Você também pode obter uma copia da licença em:                              }
{ http://www.opensource.org/licenses/lgpl-license.php                          }
{                                                                              }
{ Daniel Simões de Almeida  -  daniel@djsystem.com.br  -  www.djsystem.com.br  }
{              Praça Anita Costa, 34 - Tatuí - SP - 18270-410                  }
{                                                                              }
{******************************************************************************}

{******************************************************************************
|* Historico
|*
|* 12/08/2010: Primeira Versao
|*    Daniel Simoes de Almeida e André Moraes
******************************************************************************}

unit ACBrIBGE ;

{$I ACBr.inc}

interface

uses
  Classes, SysUtils, contnrs,
  ACBrSocket ;

const
  CIBGE_URL_UF  = 'https://servicodados.ibge.gov.br/api/v1/localidades/estados/';
  CIBGE_URL_MUN = 'https://servicodados.ibge.gov.br/api/v1/localidades/estados/XX/municipios';

type

  EACBrIBGEException = class ( Exception );

  TACBrIBGE = class;
  TACBrIBGEUFs = class;
  TACBrIBGECidades = class;

  { TACBrIBGEUF }

  TACBrIBGEUF = class
  private
    FUFs: TACBrIBGEUFs;
    fArea: Double;
    fCodRegiao: String;
    fCodUF: Integer;
    fNome: String;
    fPopulacao: Integer;
    fRegiao: String;
    fUF: String;
  public
    constructor Create;
    procedure Clear;

    property UFs: TACBrIBGEUFs read FUFs;

    property CodUF      : Integer read fCodUF       write fCodUF ;
    property UF         : String  read fUF          write fUF ;
    property Nome       : String  read fNome        write fNome ;
    property CodRegiao  : String  read fCodRegiao   write fCodRegiao ;
    property Regiao     : String  read fRegiao      write fRegiao ;
    property Area       : Double  read fArea        write fArea ;
    property Populacao  : Integer read fPopulacao   write fPopulacao ;
  end ;

  { TACBrIBGEUFs }

  TACBrIBGEUFs = class(TObjectList)
  protected
    FIBGE: TACBrIBGE;
    procedure SetObject (Index: Integer; Item: TACBrIBGEUF);
    function GetObject (Index: Integer): TACBrIBGEUF;
    procedure Insert (Index: Integer; Obj: TACBrIBGEUF);
  public
    constructor Create(AOwner: TACBrIBGE); reintroduce;

    property IBGE: TACBrIBGE read FIBGE;

    function Add (Obj: TACBrIBGEUF): Integer;
    property Objects [Index: Integer]: TACBrIBGEUF
      read GetObject write SetObject; default;

    function Find(ACodUF: Integer): TACBrIBGEUF;
    procedure SortCodUF;
    procedure SortNome;
  end;

  { TACBrIBGECidade }

  TACBrIBGECidade = class
  private
    FCidades: TACBrIBGECidades;
    fCodMunicio : Integer ;
    fMunicipio  : String ;
    fCodUF      : Integer ;
    fArea       : Double ;
    fPopulacao: Integer;

    function GetUF: String;
  public
    constructor Create;
    procedure Clear;

    property Cidades: TACBrIBGECidades read FCidades;

    property CodMunicio : Integer read fCodMunicio  write fCodMunicio ;
    property Municipio  : String  read fMunicipio   write fMunicipio ;
    property CodUF      : Integer read fCodUF       write fCodUF ;
    property UF         : String  read GetUF;
    property Area       : Double  read fArea        write fArea ;
    property Populacao  : Integer read fPopulacao   write fPopulacao ;
  end;

  TACBrIBGESortCidades = function (const Cidade1,Cidade2:TACBrIBGECidade): Integer of object;

  { TACBrIBGECidades }

  TACBrIBGECidades = class(TObjectList)
  protected
    FIBGE: TACBrIBGE;
    procedure SetObject (Index: Integer; Item: TACBrIBGECidade);
    function GetObject (Index: Integer): TACBrIBGECidade;
    procedure Insert (Index: Integer; Obj: TACBrIBGECidade);
  public
    constructor Create(AOwner: TACBrIBGE); reintroduce;

    property IBGE: TACBrIBGE read FIBGE;

    function Add (Obj: TACBrIBGECidade): Integer;
    property Objects [Index: Integer]: TACBrIBGECidade
      read GetObject write SetObject; default;

    function Find(ACodUF: Integer; AMunicipio: String): TACBrIBGECidade; overload;
    function Find(ACodMunicio: Integer): TACBrIBGECidade; overload;
    procedure SortCodMunicipio;
    procedure SortCodUFMunicipio;
  end;

  {$IFDEF RTL230_UP}
  [ComponentPlatformsAttribute(pidWin32 or pidWin64)]
  {$ENDIF RTL230_UP}		
  TACBrIBGE = class( TACBrHTTP )
  private
    fCidades : TACBrIBGECidades ;
    fOnBuscaEfetuada : TNotifyEvent ;
    fUFs: TACBrIBGEUFs;

    procedure ProcessaResposta ;
  public
    constructor Create(AOwner: TComponent); override;
    Destructor Destroy ; override ;

    property UFs : TACBrIBGEUFs  read fUFs ;
    property Cidades : TACBrIBGECidades  read fCidades ;

    function BuscarPorCodigo( const ACodigo : Integer ) : Integer ;
    function BuscarPorNome( const ACidade : String; const AUF: String = '';
      const Exata: Boolean = False; const ComparacaoCaseSensitive: Boolean = True ) : Integer ;

    procedure CarregarUFs;
    procedure CarregarCidades; overload;
    procedure CarregarCidades(const ACodUF: Integer); overload;
    procedure CarregarCidades(const AUF: String); overload;
  published
    property OnBuscaEfetuada : TNotifyEvent read fOnBuscaEfetuada
       write fOnBuscaEfetuada ;
  end ;

  function SortCidadeCodMunicipioAsc(pCidade1,pCidade2: Pointer): Integer;
  function SortCidadeCodUFMunicipioAsc(pCidade1,pCidade2: Pointer): Integer;

  function SortUFCodUFAsc(pUF1,pUF2: Pointer): Integer;
  function SortUFNomeAsc(pUF1,pUF2: Pointer): Integer;

implementation

uses
  strutils,
  blcksock, Jsons, ACBrUtil;

{ TACBrIBGEUF }

constructor TACBrIBGEUF.Create;
begin
  inherited Create;
  Clear;
end;

procedure TACBrIBGEUF.Clear;
begin
  fArea := 0;
  fCodRegiao := '';
  fCodUF := 0;
  fNome := '';
  fPopulacao := 0;
  fRegiao := '';
  fUF := '';
end;

{ TACBrIBGEUFs }

constructor TACBrIBGEUFs.Create(AOwner: TACBrIBGE);
begin
  inherited Create(True);
  FIBGE := AOwner;
end;

procedure TACBrIBGEUFs.SetObject(Index: Integer; Item: TACBrIBGEUF);
begin
  Item.FUFs := Self;
  inherited SetItem (Index, Item) ;
end;

function TACBrIBGEUFs.GetObject(Index: Integer): TACBrIBGEUF;
begin
  Result := inherited GetItem(Index) as TACBrIBGEUF ;
end;

procedure TACBrIBGEUFs.Insert(Index: Integer; Obj: TACBrIBGEUF);
begin
  Obj.FUFs := Self;
  inherited Insert(Index, Obj);
end;

function TACBrIBGEUFs.Add(Obj: TACBrIBGEUF): Integer;
begin
  Obj.FUFs := Self;
  Result := inherited Add(Obj) ;
end;

function TACBrIBGEUFs.Find(ACodUF: Integer): TACBrIBGEUF;
var
  I: Integer;
begin
  I := 0;
  Result := Nil;
  while (I < Count) and (Result = Nil) do
  begin
    if Objects[I].CodUF = ACodUF then
      Result := Objects[I]
    else
      Inc(I);
  end;
end;

procedure TACBrIBGEUFs.SortCodUF;
begin
  Sort(SortUFCodUFAsc);
end;

procedure TACBrIBGEUFs.SortNome;
begin
  Sort(SortUFNomeAsc);
end;

function SortUFCodUFAsc(pUF1, pUF2: Pointer): Integer;
var
  UF1, UF2: TACBrIBGEUF;
begin
  UF1 := TACBrIBGEUF(pUF1);
  UF2 := TACBrIBGEUF(pUF2);

  if UF1.CodUF > UF2.CodUF then
    Result := 1
  else if UF1.CodUF < UF2.CodUF then
    Result := -1
  else
    Result := 0;
end;

function SortUFNomeAsc(pUF1, pUF2: Pointer): Integer;
var
  UF1, UF2: TACBrIBGEUF;
begin
  UF1 := TACBrIBGEUF(pUF1);
  UF2 := TACBrIBGEUF(pUF2);

  if UF1.Nome > UF2.Nome then
    Result := 1
  else if UF1.Nome < UF2.Nome then
    Result := -1
  else
    Result := 0;
end;

{ TACBrIBGECidade }

constructor TACBrIBGECidade.Create;
begin
  inherited Create;
  Clear;
end ;

function TACBrIBGECidade.GetUF: String;
var
  AUF: TACBrIBGEUF;
begin
  Result := '';
  if not Assigned(FCidades) then
    Exit;

  AUF := FCidades.IBGE.UFs.Find(CodUF);
  if Assigned(AUF) then
    Result := AUF.UF
end;

procedure TACBrIBGECidade.Clear;
begin
  fArea := 0 ;
  fMunicipio := '';
  fCodMunicio := 0 ;
  fCodUF := 0 ;
end;

{ TACBrIBGECidades }

procedure TACBrIBGECidades.SetObject(Index : Integer ; Item : TACBrIBGECidade) ;
begin
  inherited SetItem (Index, Item) ;
end ;

function TACBrIBGECidades.GetObject(Index : Integer) : TACBrIBGECidade ;
begin
  Result := inherited GetItem(Index) as TACBrIBGECidade ;
end ;

procedure TACBrIBGECidades.Insert(Index : Integer ; Obj : TACBrIBGECidade) ;
begin
  inherited Insert(Index, Obj);
end ;

constructor TACBrIBGECidades.Create(AOwner: TACBrIBGE);
begin
  inherited Create(True);
  FIBGE := AOwner;
end;

function TACBrIBGECidades.Add(Obj : TACBrIBGECidade) : Integer ;
begin
  Result := inherited Add(Obj) ;
end ;

function TACBrIBGECidades.Find(ACodUF: Integer; AMunicipio: String
  ): TACBrIBGECidade;
var
  I: Integer;
begin
  AMunicipio := LowerCase(TiraAcentos(AMunicipio));
  Result := Nil;
  if (AMunicipio = '') then
    Exit;

  I := 0;
  while (I < Count) and (Result = Nil) do
  begin
    if (Objects[I].CodUF = ACodUF) and (LowerCase(TiraAcentos(Objects[I].Municipio)) = AMunicipio) then
      Result := Objects[I]
    else
      Inc(I);
  end;
end;

function TACBrIBGECidades.Find(ACodMunicio: Integer): TACBrIBGECidade;
var
  I: Integer;
begin
  I := 0;
  Result := Nil;
  while (I < Count) and (Result = Nil) do
  begin
    if Objects[I].CodMunicio = ACodMunicio then
      Result := Objects[I]
    else
      Inc(I);
  end;
end;

procedure TACBrIBGECidades.SortCodMunicipio;
begin
  Sort(SortCidadeCodMunicipioAsc);
end;

procedure TACBrIBGECidades.SortCodUFMunicipio;
begin
  Sort(SortCidadeCodUFMunicipioAsc);
end;

function SortCidadeCodMunicipioAsc(pCidade1, pCidade2: Pointer): Integer;
var
  Cidade1, Cidade2: TACBrIBGECidade;
begin
  Cidade1 := TACBrIBGECidade(pCidade1);
  Cidade2 := TACBrIBGECidade(pCidade2);

  if Cidade1.CodMunicio > Cidade2.CodMunicio then
    Result := 1
  else if Cidade1.CodMunicio < Cidade2.CodMunicio then
    Result := -1
  else
    Result := 0;
end;

function SortCidadeCodUFMunicipioAsc(pCidade1, pCidade2: Pointer): Integer;
var
  Cidade1, Cidade2: TACBrIBGECidade;
  Cidade1Str, Cidade2Str: String;
begin
  Cidade1 := TACBrIBGECidade(pCidade1);
  Cidade2 := TACBrIBGECidade(pCidade2);
  Cidade1Str := IntToStrZero(Cidade1.CodUF, 2) + Cidade1.Municipio;
  Cidade2Str := IntToStrZero(Cidade2.CodUF, 2) + Cidade2.Municipio;

  if Cidade1Str > Cidade2Str then
    Result := 1
  else if Cidade1Str < Cidade2Str then
    Result := -1
  else
    Result := 0;
end;

{ TACBrIBGE }

constructor TACBrIBGE.Create(AOwner : TComponent) ;
begin
  inherited Create(AOwner) ;

  fOnBuscaEfetuada := nil ;
  fCidades := TACBrIBGECidades.create(Self);
  fUFs := TACBrIBGEUFs.Create(Self);

  HTTPSend.Sock.SSL.SSLType := LT_TLSv1_2;
end ;

destructor TACBrIBGE.Destroy ;
begin
  fCidades.Free ;
  fUFs.Free;

  inherited Destroy ;
end ;

function TACBrIBGE.BuscarPorCodigo(const ACodigo : Integer) : Integer ;
begin
  fCidades.Clear;

  if ACodigo = 0 then
     raise EACBrIBGEException.Create( ACBrStr('Código do Município deve ser informado') );

  //HTTPGet(CIBGE_URL + '?codigo='+IntToStr(ACodigo) ) ;
  ProcessaResposta;

  Result := fCidades.Count;

  if Assigned( OnBuscaEfetuada ) then
     OnBuscaEfetuada( Self );

end ;

function TACBrIBGE.BuscarPorNome(const ACidade : String ; const AUF : String ;
  const Exata : Boolean; const ComparacaoCaseSensitive: Boolean) : Integer ;
var
  I : Integer ;
  Param, CidadeAchar, CidadeLista: String ;
begin
  fCidades.Clear;

  Param := AjustaParam( ACidade ) ;
  if Param = '' then
     raise EACBrIBGEException.Create( ACBrStr('Nome do Município deve ser informado') );

  //HTTPGet(CIBGE_URL + '?nome='+Param ) ;
  HTTPGet('https://www.ibge.gov.br/geociencias-novoportal/organizacao-do-territorio/estrutura-territorial/15761-areas-dos-municipios.html?&t=destaques');

  ProcessaResposta;

  // Aplicando filtros (se informados) //
  if (AUF <> '') or Exata then
  begin
    CidadeAchar := TiraAcentos(ACidade);
    if not ComparacaoCaseSensitive then
      CidadeAchar := UpperCase(CidadeAchar);

    I := 0;
    while I < fCidades.Count do
    begin
      if (AUF <> '') and (fCidades[I].UF <> AUF) then
      begin
         fCidades.Delete(I);
         continue;
      end;

      if Exata then
      begin
        CidadeLista := TiraAcentos(fCidades[I].Municipio);
        if not ComparacaoCaseSensitive then
          CidadeLista := UpperCase(CidadeLista);

        if (CidadeLista <> CidadeAchar) then
        begin
          fCidades.Delete(I);
          continue;
        end;
      end;

      Inc( I ) ;
    end ;
  end ;

  Result := fCidades.Count;

  if Assigned( OnBuscaEfetuada ) then
     OnBuscaEfetuada( Self );

end ;

procedure TACBrIBGE.CarregarUFs;
var
  AJSon: TJson;
  I: Integer;
  AUF: TACBrIBGEUF;
  SL: TStringList;
  JSonUF: TJsonObject;
begin
  fUFs.Clear;
  HTTPGet(CIBGE_URL_UF);

  AJSon := TJson.Create;
  try
    //DEBUG
    //SL := TStringList.Create;
    //SL.LoadFromFile('c:\temp\estados.json');
    //AJSon.Parse(SL.Text);
    //SL.Free;
    AJSon.Parse(RespHTTP.Text);

    For I := 0 to AJSon.Count-1 do
    begin
      JSonUF := AJSon.Get(I).AsObject;

      AUF := TACBrIBGEUF.Create;
      AUF.CodUF := JSonUF.Values['id'].AsInteger;
      AUF.UF    := JSonUF.Values['sigla'].AsString;
      AUF.Nome  := JSonUF.Values['nome'].AsString;
      AUF.Regiao:= JSonUF.Values['regiao'].AsObject.Values['nome'].AsString;

      fUFs.Add(AUF);
    end;

  finally
    AJSon.Free;
  end;
end;

procedure TACBrIBGE.CarregarCidades(const ACodUF: Integer);
var
  AJSon: TJson;
  I: Integer;
  AUF: TACBrIBGEUF;
  SL: TStringList;
  JSonUF: TJsonObject;
begin
  if (fUFs.Count = 0) then
    CarregarUFs;

  HTTPGet(CIBGE_URL_UFS);

  AJSon := TJson.Create;
  try
    //DEBUG
    //SL := TStringList.Create;
    //SL.LoadFromFile('c:\temp\estados.json');
    //AJSon.Parse(SL.Text);
    //SL.Free;
    AJSon.Parse(RespHTTP.Text);

    For I := 0 to AJSon.Count-1 do
    begin
      JSonUF := AJSon.Get(I).AsObject;

      AUF := TACBrIBGEUF.Create;
      AUF.CodUF := JSonUF.Values['id'].AsInteger;
      AUF.UF    := JSonUF.Values['sigla'].AsString;
      AUF.Nome  := JSonUF.Values['nome'].AsString;
      AUF.Regiao:= JSonUF.Values['regiao'].AsObject.Values['nome'].AsString;

      fUFs.Add(AUF);
    end;

  finally
    AJSon.Free;
  end;
end;

procedure TACBrIBGE.CarregarCidades(const AUF: String);
begin
  if (fUFs.Count = 0) then
    CarregarUFs

end;

procedure TACBrIBGE.ProcessaResposta ;
Var
  Buffer : String ;
  PI, PF, I, CodMun, CodUF : Integer ;
  SL : TStringList ;
  Cidade : TACBrIBGECidade ;
begin
  Cidades.Clear;

  Buffer := LowerCase(RespHTTP.Text) ;
  PI := pos('<div id="miolo_interno">', Buffer ) ;

  if PI > 0 then
  begin
    PI := PosEx('<table', Buffer, PI ) ;   // Inicio da Tabela
    if PI > 0 then
    begin
      PF := PosEx('</table>', Buffer, PI ) ;
      if PF > 0 then
      begin
        SL := TStringList.Create;
        try
          SL.Text := Trim( StripHTML( copy( RespHTTP.Text, PI, PF ) ));

          // DEBUG //
          // WriteToTXT( 'C:\TEMP\HTTP.txt', SL.Text );

          I := 0 ;
          while I < SL.Count do
          begin
            CodUF := StrToIntDef(Trim(SL[I]),0);

            if (CodUF > 0) and (CodUF < 100) then
            begin
              if (SL.Count-I) >= 5 then
              begin
                CodMun := StrToIntDef( Trim(SL[I+2]), 0);

                if CodMun > 0 then
                begin
                   Cidade := TACBrIBGECidade.Create;

                   Cidade.CodUF      := CodUF;
                   //Cidade.UF         := Trim( SL[I+1] );
                   //Cidade.CodMunicio := CodMun;
                   //Cidade.Municipio  := Trim( SL[I+3] );
                   //Cidade.Area       := StringToFloatDef( Trim( SL[I+4] ), 0 );

                   Cidades.Add(Cidade);
                   I := I + 4 ;
                end ;
              end ;
            end ;

            Inc(I) ;
          end ;
        finally
          SL.Free ;
        end ;
      end ;
    end ;
  end ;
end ;

end.

